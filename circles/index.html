<html>

	<head>
		<title>WebGL</title>
		<meta charset="utf-8">
		
		<style>
			.general-options{
				position: absolute;
				margin: 20;
			}
			.general-options span {
				color: white;
				font-family: monospace;
			}
			
			.function-options {
				margin-top: 10;
				display: none;
			}
			.function-options span {
				color: white;
				font-family: monospace;
			}
			
			.function-string {
				position: absolute;
				right: 20;
				top: 20;
				margin: 0;
			}
			.function-string span {
				color: white;
				font-family: monospace;
			}
			
			.command-div {
				position: absolute;
				bottom: 20;
				left: 20;
				margin: 0;
				display: none;
			}
			
			.ftr {
				position: absolute;
				right: 20;
				margin: 0;
			}
			.ftr-bottom {
				bottom: 10;
			}
			.ftr-top {
				bottom: 20;
			}
			.ftr-version {
				bottom: 34;
			}
			.ftr span {
				color: white;
				font-family: monospace;
			}
		</style>

		<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
		<script type="text/javascript" src="webgl-utils.js"></script>

		<script id="circle-shader-fs" type="x-shader/x-fragment">
			precision mediump float;

			varying vec2 vTextureCoord;

			uniform sampler2D uSampler;

			uniform vec3 uColor;
			uniform float uBrightness;

			void main(void) {
				vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
				gl_FragColor = textureColor * vec4(uColor, 1.0);
			}
		</script>

		<script id="circle-shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;

			varying vec2 vTextureCoord;

			void main(void) {
				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
				vTextureCoord = aTextureCoord;
			}
		</script>

		<script id="grid-shader-fs" type="x-shader/x-fragment">
			precision mediump float;
			
			void main(void) {
				gl_FragColor = vec4(0.125, 0.125, 0.125, 1.0);
			}
		</script>

		<script id="grid-shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			
			void main(void) {
				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
			}
		</script>

		<script type="text/javascript">

			var canvas;
			var gl;
			var SIMULATION_SCALE = 6;
			
			var worldOffsetX = 0.0;
			var worldOffsetY = 0.0;
			
			// DOM Objects
			var DOM_sliderSpeed;
			var DOM_sliderAmplitude;
			var DOM_sliderNumberOfCircles;
			var DOM_sliderZoom;
			var DOM_selectFunction;
			var DOM_trackingCheckbox;
			var DOM_showGrid;
			var DOM_showFunctionString;
			var DOM_commandLineDiv;
			var DOM_commandLineInput;
			var DOM_trackingPositionSpan;
			var DOM_functionStringX;
			var DOM_functionStringY;
			var functionStringUpdateBuffer = 0;
			var DOM_functionOption_rose_k;
			var DOM_functionOption_lissajous_a;
			var DOM_functionOption_lissajous_b;
			var DOM_functionOption_lissajous_kx;
			var DOM_functionOption_lissajous_ky;
			var DOM_functionOption_lissajous_delta;
			var DOM_functionOption_limacon_a;
			var DOM_functionOption_limacon_b;
			
			var previousCommands = [];
			var previousCommandIndex = 0;
			
			var colorVertex = 0.0;
			var clearColorOpacity = 0.2;
			var clearColorStep = 0.001;
			var clearColorDampen = 15.0;
			
			var goBonkers = false;
			var goBonkersCounter = 0;

			function initGL(canvas) {
				try {
					gl = canvas.getContext("experimental-webgl");
					gl.viewportWidth = canvas.width;
					gl.viewportHeight = canvas.height;

					gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
					gl.enable(gl.BLEND);
				} catch (e) {
				}
				if (!gl) {
					alert("Could not initialise WebGL, sorry :-(");
				}
			}

			function resizeGL() {
				canvas.width = document.body.clientWidth;
				canvas.height = document.body.clientHeight;
				
				gl.viewportWidth = canvas.width;
				gl.viewportHeight = canvas.height;
				
				gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			}

			function getShader(gl, id) {
				var shaderScript = document.getElementById(id);
				if (!shaderScript) {
					return null;
				}

				var str = "";
				var k = shaderScript.firstChild;
				while (k) {
					if (k.nodeType == 3) {
						str += k.textContent;
					}
					k = k.nextSibling;
				}

				var shader;
				if (shaderScript.type == "x-shader/x-fragment") {
					shader = gl.createShader(gl.FRAGMENT_SHADER);
				} else if (shaderScript.type == "x-shader/x-vertex") {
					shader = gl.createShader(gl.VERTEX_SHADER);
				} else {
					return null;
				}

				gl.shaderSource(shader, str);
				gl.compileShader(shader);

				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					alert(gl.getShaderInfoLog(shader));
					return null;
				}

				return shader;
			}

			var circleShaderProgram;
			var gridShaderProgram;

			function initShaders() {
				var fragmentShader = getShader(gl, "circle-shader-fs");
				var vertexShader = getShader(gl, "circle-shader-vs");

				circleShaderProgram = gl.createProgram();
				gl.attachShader(circleShaderProgram, vertexShader);
				gl.attachShader(circleShaderProgram, fragmentShader);
				gl.linkProgram(circleShaderProgram);

				if (!gl.getProgramParameter(circleShaderProgram, gl.LINK_STATUS)) {
					alert("Could not initialise shaders");
				}

				gl.useProgram(circleShaderProgram);

				circleShaderProgram.vertexPositionAttribute = gl.getAttribLocation(circleShaderProgram, "aVertexPosition");
				gl.enableVertexAttribArray(circleShaderProgram.vertexPositionAttribute);

				circleShaderProgram.textureCoordAttribute = gl.getAttribLocation(circleShaderProgram, "aTextureCoord");
				gl.enableVertexAttribArray(circleShaderProgram.textureCoordAttribute);

				circleShaderProgram.pMatrixUniform = gl.getUniformLocation(circleShaderProgram, "uPMatrix");
				circleShaderProgram.mvMatrixUniform = gl.getUniformLocation(circleShaderProgram, "uMVMatrix");
				circleShaderProgram.samplerUniform = gl.getUniformLocation(circleShaderProgram, "uSampler");
				circleShaderProgram.colorUniform = gl.getUniformLocation(circleShaderProgram, "uColor");
				
				gl.disableVertexAttribArray(circleShaderProgram.vertexPositionAttribute);
				gl.disableVertexAttribArray(circleShaderProgram.textureCoordAttribute);
				
				/*****/
				
				fragmentShader = getShader(gl, "grid-shader-fs");
				vertexShader = getShader(gl, "grid-shader-vs");

				gridShaderProgram = gl.createProgram();
				gl.attachShader(gridShaderProgram, vertexShader);
				gl.attachShader(gridShaderProgram, fragmentShader);
				gl.linkProgram(gridShaderProgram);

				if (!gl.getProgramParameter(gridShaderProgram, gl.LINK_STATUS)) {
					alert("Could not initialise shaders");
				}

				gl.useProgram(gridShaderProgram);

				gridShaderProgram.vertexPositionAttribute = gl.getAttribLocation(gridShaderProgram, "aVertexPosition");
				gl.enableVertexAttribArray(gridShaderProgram.vertexPositionAttribute);

				gridShaderProgram.pMatrixUniform = gl.getUniformLocation(gridShaderProgram, "uPMatrix");
				gridShaderProgram.mvMatrixUniform = gl.getUniformLocation(gridShaderProgram, "uMVMatrix");
				
				gl.disableVertexAttribArray(gridShaderProgram.vertexPositionAttribute);
			}


			function handleLoadedTexture(texture) {
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

				// go ahead and activate the loaded circle texture since it's the only texture we need
				// to draw in the entire project
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, circleTexture);
			}


			var circleTexture;

			function initTexture() {
				circleTexture = gl.createTexture();
				circleTexture.image = new Image();
				circleTexture.image.onload = function () {
					handleLoadedTexture(circleTexture)
				}

				circleTexture.image.src = "circle.png";
			}


			var mvMatrix = mat4.create();
			var mvMatrixStack = [];
			var pMatrix = mat4.create();

			function mvPushMatrix() {
				var copy = mat4.create();
				mat4.set(mvMatrix, copy);
				mvMatrixStack.push(copy);
			}

			function mvPopMatrix() {
				if (mvMatrixStack.length == 0) {
					throw "Invalid popMatrix!";
				}
				mvMatrix = mvMatrixStack.pop();
			}

			function setGridShaderMatrixUniforms() {
				gl.uniformMatrix4fv(gridShaderProgram.pMatrixUniform, false, pMatrix);
				gl.uniformMatrix4fv(gridShaderProgram.mvMatrixUniform, false, mvMatrix);
			}
			
			function setCircleShaderMatrixUniforms() {
				gl.uniformMatrix4fv(circleShaderProgram.pMatrixUniform, false, pMatrix);
				gl.uniformMatrix4fv(circleShaderProgram.mvMatrixUniform, false, mvMatrix);
			}

			function degToRad(degrees) {
				return degrees * Math.PI / 180;
			}

			var currentlyPressedKeys = {};
			var keyFlag = {};
			keyFlag[192] = false;
			keyFlag[38] = false;
			keyFlag[40] = false;

			function handleKeyDown(event) {
				currentlyPressedKeys[event.keyCode] = true;
				if (event.keyCode == 192) return false;
			}
			function handleKeyUp(event) {
				currentlyPressedKeys[event.keyCode] = false;
				keyFlag[event.keyCode] = false;
				if (event.keyCode == 192) return false;
			}

			function handleKeys() {
				if (currentlyPressedKeys[192] && keyFlag[192] == false) {
					// grave aka tilde
					if (DOM_commandLineDiv.style.display == "none") {
						DOM_commandLineDiv.style.display = "inline";
						DOM_commandLineInput.value = "";
						DOM_commandLineInput.focus();
					} else {
						DOM_commandLineDiv.style.display = "none";
						DOM_commandLineInput.value = "";
					}
					
					previousCommandIndex = previousCommands.length - 1;
					if (previousCommandIndex < 0) {
						previousCommandIndex = 0;
					}
					
					keyFlag[192] = true;
				}
				if (currentlyPressedKeys[27]) {
					if (DOM_commandLineDiv.style.display == "inline") {
						DOM_commandLineInput.value = "";
						previousCommandIndex = previousCommands.length - 1;
					}
				}
				if (currentlyPressedKeys[13] && DOM_commandLineInput.value != "") {
					parseCommandLineInput();
					DOM_commandLineInput.value = "";
				}
				
				if (currentlyPressedKeys[107]) {
					DOM_sliderZoom.value = parseInt(DOM_sliderZoom.value) + 2;
					if (DOM_sliderZoom.value > 200) DOM_sliderZoom.value = 200;
				}
				if (currentlyPressedKeys[109]) {
					DOM_sliderZoom.value = parseInt(DOM_sliderZoom.value) - 2;
					if (DOM_sliderZoom.value < 1) DOM_sliderZoom.value = 1;
				}
				
				if (currentlyPressedKeys[38] && keyFlag[38] == false) {
					// Up cursor key
					if (DOM_commandLineDiv.style.display == "inline") {
						if (previousCommands.length > 0) {
							DOM_commandLineInput.value = previousCommands[previousCommandIndex];
							previousCommandIndex--;
							if (previousCommandIndex < 0) {
								previousCommandIndex = 0;
							}
						}
						keyFlag[38] = true;
					} else {
						worldOffsetY--;
					}
				}
				if (currentlyPressedKeys[40] && keyFlag[40] == false) {
					// Down cursor key
					if (DOM_commandLineDiv.style.display == "inline") {
						previousCommandIndex++;
						if (previousCommandIndex >= previousCommands.length) {
							previousCommandIndex = previousCommands.length - 1;
							DOM_commandLineInput.value = "";
						} else {
							DOM_commandLineInput.value = previousCommands[previousCommandIndex];
						}
					keyFlag[40] = true;
					} else {
						worldOffsetY++;
					}
				}
				if (currentlyPressedKeys[37]) {
					// left arrow
					if (DOM_commandLineDiv.style.display != "inline") worldOffsetX++;
				}
				if (currentlyPressedKeys[39]) {
					// right arrow
					if (DOM_commandLineDiv.style.display != "inline") worldOffsetX--;
				}
			}
			
			function parseCommandLineInput() {
				var input = DOM_commandLineInput.value;
				if (input.startsWith("circles=")) {
					var n = parseInt(input.substring(8));
					if (n) {
						if (0 < n && n <= 200) {
							DOM_sliderNumberOfCircles.value = n;
							initWorldObjects();
							displayCommandLineMessage("circles set to " + n, true);
						} else {
							displayCommandLineMessage("0 < circles <= 200", false);
						}
					}
				} else if (input.startsWith("speed=")) {
					var n = parseInt(input.substring(6));
					if (n) {
						if (0 < n && n <= 100) {
							DOM_sliderSpeed.value = n;
							displayCommandLineMessage("speed set to " + n, true);
						} else {
							displayCommandLineMessage("0 < speed <= 100", false);
						}
					}
				} else if (input.startsWith("zoom=")) {
					var n = parseInt(input.substring(5));
					if (n) {
						if (0 < n && n <= 200) {
							DOM_sliderZoom.value = n;
							displayCommandLineMessage("zoom set to " + n, true);
						} else {
							displayCommandLineMessage("0 < zoom <= 200", false);
						}
					}
				} else if (input.startsWith("amplitude=")) {
					var n = parseFloat(input.substring(10));
					if (n) {
						if (0 < n && n <= 10) {
							DOM_sliderAmplitude.value = n * 10.0;
							displayCommandLineMessage("amplitude set to " + n, true);
						} else {
							displayCommandLineMessage("0 < amplitude <= 10", false);
						}
					} else {
						displayCommandLineMessage("amplitude=<float>", false);
					}
				} else if (input == "reset") {
					DOM_sliderSpeed.value = defaultDOMSettings.speed;
					DOM_sliderNumberOfCircles.value = defaultDOMSettings.numberOfCircles;
					DOM_sliderZoom.value = defaultDOMSettings.zoom;
					initWorldObjects();
					worldOffsetX = 0.0;
					worldOffsetY = 0.0;
					DOM_showGrid.checked = false;
					DOM_trackingCheckbox.checked = false;
					DOM_showFunctionString.checked = true;
					DOM_selectFunction.value = "circle";
					displayCommandLineMessage("reset everything", true);
				} else if (input == "newcolors") {
					for (var i in circles) {
						circles[i].randomizeColors();
					}
					displayCommandLineMessage("new colors to all circles", true);
				} else if (input.startsWith("drawgrid=")) {
					if (input.substring(9) == "true") {
						DOM_showGrid.checked = true;
						displayCommandLineMessage("showing grid", true);
					} else {
						DOM_showGrid.checked = false;
						displayCommandLineMessage("hiding grid", true);
					}
				} else if (input == "clear") {
					while (DOM_commandLineDiv.children.length > 1) {
						DOM_commandLineDiv.removeChild(DOM_commandLineDiv.firstChild);
					}
				} else if (input.startsWith("track=")) {
					if (input.substring(6) == "true") {
						DOM_trackingCheckbox.checked = true;
						displayCommandLineMessage("tracking circle 0", true);
					} else {
						DOM_trackingCheckbox.checked = false;
						displayCommandLineMessage("untracking circle 0", true);
					}
				} else if (input == "gobonkers") {
					goBonkers = true;
				} else if (input == "enoughbonkers") {
					goBonkers = false;
				} else if (input == "regen") {
					initWorldObjects();
					displayCommandLineMessage("regenerated circles", true);
				} else if (input == "help") {
					displayCommandLineHelp();
				} else {
					displayCommandLineMessage("unknown input: " + input, false);
				}
				
				previousCommands.push(input);
				previousCommandIndex = previousCommands.length - 1;
			}

			var circleVertexPositionBuffer;
			var circleVertexTextureCoordBuffer;
			var gridVertexPositionBuffer;

			function initBuffers() {
				circleVertexPositionBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, circleVertexPositionBuffer);
				vertices = [
					-1.0, -1.0,  0.0,
					 1.0, -1.0,  0.0,
					-1.0,  1.0,  0.0,
					 1.0,  1.0,  0.0
				];
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
				circleVertexPositionBuffer.itemSize = 3;
				circleVertexPositionBuffer.numItems = 4;

				circleVertexTextureCoordBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, circleVertexTextureCoordBuffer);
				var textureCoords = [
					0.0, 0.0,
					1.0, 0.0,
					0.0, 1.0,
					1.0, 1.0
				];
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
				circleVertexTextureCoordBuffer.itemSize = 2;
				circleVertexTextureCoordBuffer.numItems = 4;
				
				gridVertexPositionBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, gridVertexPositionBuffer);
				vertices = [
					-(SIMULATION_SCALE / 2.0), -(SIMULATION_SCALE / 2.0),  0.0,
					 (SIMULATION_SCALE / 2.0), -(SIMULATION_SCALE / 2.0),  0.0,
					 (SIMULATION_SCALE / 2.0),  (SIMULATION_SCALE / 2.0),  0.0,
					-(SIMULATION_SCALE / 2.0),  (SIMULATION_SCALE / 2.0),  0.0,
				];
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
				gridVertexPositionBuffer.itemSize = 3;
				gridVertexPositionBuffer.numItems = 4;
			}
			
			class Circle {
			
				constructor(startingTheta) {
					this.theta = startingTheta;
					this.updatePosition();
					this.randomizeColors();
				};
				
				draw(isFirstCircle) {
					mvPushMatrix();
					mat4.translate(mvMatrix, [this.x, this.y, 0.0]);
					
					if (DOM_trackingCheckbox.checked) {
						if (isFirstCircle) {
							gl.uniform3f(circleShaderProgram.colorUniform, this.r * 2.0, this.g * 2.0, this.b * 2.0);
						} else {
							gl.uniform3f(circleShaderProgram.colorUniform, this.r / 8.0, this.g / 8.0, this.b / 8.0);
						}
					} else {
						gl.uniform3f(circleShaderProgram.colorUniform, this.r, this.g, this.b);
					}
					
					setCircleShaderMatrixUniforms();
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, circleVertexPositionBuffer.numItems);
					mvPopMatrix();
				}
				
				animate(elapsedTime) {
					//              PI          slider value   constant   ms per frame   elapsed ms
					this.theta += Math.PI * DOM_sliderSpeed.value * 0.0001 * (60 / 1000) * elapsedTime;
					if (this.theta > 2 * Math.PI) {
						this.theta = 0.0;
					}
					this.updatePosition();
				}
				
				randomizeColors() {
					this.r = Math.random();
					this.g = Math.random();
					this.b = Math.random();
				}
				
				updatePosition() {
					var func = DOM_selectFunction.value;
					if (func == "rose") {
						this.x = Math.cos(DOM_functionOption_rose_k.value * this.theta) * Math.cos(this.theta);
						this.y = Math.cos(DOM_functionOption_rose_k.value * this.theta) * Math.sin(this.theta);
					} else if (func == "cardioid") {
						this.x = Math.cos(this.theta)*(1 - Math.cos(this.theta));
						this.y = Math.sin(this.theta)*(1 - Math.cos(this.theta));
					} else if (func == "circle") {
						this.x = Math.cos(this.theta);
						this.y = Math.sin(this.theta);
					} else if (func == "lissajous") {
						this.x = DOM_functionOption_lissajous_a.value * Math.sin(DOM_functionOption_lissajous_kx.value * this.theta + (Math.PI * 0.5 * DOM_functionOption_lissajous_delta.value));
						this.y = DOM_functionOption_lissajous_b.value * Math.sin(DOM_functionOption_lissajous_ky.value * this.theta);
					} else if (func == "butterfly") {
						var val = Math.sin(this.theta / 12.0);
						this.x = Math.sin(this.theta) * (   Math.pow(Math.E, Math.cos(this.theta))   -   (2 * Math.cos(4 * this.theta))   -   ( Math.pow(val, 5))  );
						this.y = Math.cos(this.theta) * (   Math.pow(Math.E, Math.cos(this.theta))   -   (2 * Math.cos(4 * this.theta))   -   ( Math.pow(val, 5))  );
					} else if (func == "limacon") {
						var a = DOM_functionOption_limacon_a.value - 4;
						var b = DOM_functionOption_limacon_b.value - 4;
						this.x = a * Math.cos(this.theta) + b * Math.cos(this.theta) * Math.cos(this.theta);
						this.y = a * Math.sin(this.theta) + b * Math.cos(this.theta) * Math.sin(this.theta);
					}
					
					this.x *= DOM_sliderAmplitude.value / 10.0;
					this.y *= DOM_sliderAmplitude.value / 10.0;
					
					this.x *= SIMULATION_SCALE;
					this.y *= SIMULATION_SCALE;
					
				}
			}
			
			var circles = [];

			function initWorldObjects() {
				var numCircles = DOM_sliderNumberOfCircles.value;
				circles = [];

				for (var i=0; i < numCircles; i++) {
					circles.push(new Circle((i * 2 / numCircles) * Math.PI));
				}
			}

			function drawScene() {
				gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				// set up perspective matrix
				mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 400.0, pMatrix);
				
				// translate the world back
				mat4.identity(mvMatrix);
				mat4.translate(mvMatrix, [worldOffsetX, worldOffsetY, -(260 - DOM_sliderZoom.value)]);
				
				updateClearColor();
				
				// draw circles
				drawCircles();
				
				// Draw grid
				if (DOM_showGrid.checked) {
					drawGrid();
				}
				
				// show/hide track coordinates
				if (DOM_trackingCheckbox.checked) {
					if (DOM_trackingPositionSpan.style.display == "none") DOM_trackingPositionSpan.style.display = "inline";
					DOM_trackingPositionSpan.innerHTML = " (" + (Math.round(circles[0].x * 100 / SIMULATION_SCALE) / 100).toFixed(2) + ", " + (Math.round(circles[0].y * 100 / SIMULATION_SCALE) / 100).toFixed(2) + "), &theta; = " + (Math.round((circles[0].theta / Math.PI) * 100) / 100.0).toFixed(2) + " &pi;";
				} else {
					if (DOM_trackingPositionSpan.style.display == "inline") DOM_trackingPositionSpan.style.display = "none";
				}
				
				if (DOM_showFunctionString.checked) {
					functionStringUpdateBuffer++;
					if (functionStringUpdateBuffer > 15) {
						functionStringUpdateBuffer = 0;
						var func = DOM_selectFunction.value;
						var amplitude = (Math.round(DOM_sliderAmplitude.value * 10) / 100.0);
						if (func == "rose") {
							DOM_functionStringX.innerHTML = "X = " + amplitude + " * cos(" + DOM_functionOption_rose_k.value + " * &theta;) * cos(&theta;)";
							DOM_functionStringY.innerHTML = "Y = " + amplitude + " * cos(" + DOM_functionOption_rose_k.value + " * &theta;) * sin(&theta;)";
						} else if (func == "cardioid") {
							DOM_functionStringX.innerHTML = "X = " + amplitude + " * cos(&theta;) * (1 - cos(&theta;))";
							DOM_functionStringY.innerHTML = "Y = " + amplitude + " * sin(&theta;) * (1 - cos(&theta;))";
						} else if (func == "circle") {
							DOM_functionStringX.innerHTML = "X = " + amplitude + " * cos(&theta;)";
							DOM_functionStringY.innerHTML = "Y = " + amplitude + " * sin(&theta;)";
						} else if (func == "lissajous") {
							DOM_functionStringX.innerHTML = "X = " + amplitude + " * [ " + DOM_functionOption_lissajous_a.value + " * sin(" + DOM_functionOption_lissajous_kx.value + " * &theta; + " + (0.5 * DOM_functionOption_lissajous_delta.value) + "&pi;) ]";
							DOM_functionStringY.innerHTML = "Y = " + amplitude + " * [ " + DOM_functionOption_lissajous_b.value + " * sin(" + DOM_functionOption_lissajous_ky.value + " * &theta;) ]";
						} else if (func == "butterfly") {
							DOM_functionStringX.innerHTML = "X = " + amplitude + " * sin(&theta;) * [ e^cos(&theta;) - 2cos(4 * &theta;) - sin^5(&theta; / 12) ]";
							DOM_functionStringY.innerHTML = "Y = " + amplitude + " * cos(&theta;) * [ e^cos(&theta;) - 2cos(4 * &theta;) - sin^5(&theta; / 12) ]";
						} else if (func == "limacon") {
							var a = DOM_functionOption_limacon_a.value - 4;
							var b = DOM_functionOption_limacon_b.value - 4;
							DOM_functionStringX.innerHTML = "X = " + amplitude + " * [ " + a + " * cos(&theta;) + " + b + " * cos^2(&theta;) ]";
							DOM_functionStringY.innerHTML = "Y = " + amplitude + " * [ " + a + " * sin(&theta;) + " + b + " * cos(&theta;)sin(&theta;) ]";
						}
					}
				}
				
				if (goBonkers) {
					goBonkersCounter++;
					if (goBonkersCounter > 4) {
						for (var i in circles) {
							circles[i].randomizeColors();
						}
						goBonkersCounter = 0;
					}
				}
			}
			
			function drawCircles() {
				gl.useProgram(circleShaderProgram);
				gl.enableVertexAttribArray(circleShaderProgram.vertexPositionAttribute);
				gl.enableVertexAttribArray(circleShaderProgram.textureCoordAttribute);
				
				gl.uniform1i(circleShaderProgram.samplerUniform, 0);

				gl.bindBuffer(gl.ARRAY_BUFFER, circleVertexTextureCoordBuffer);
				gl.vertexAttribPointer(circleShaderProgram.textureCoordAttribute, circleVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

				gl.bindBuffer(gl.ARRAY_BUFFER, circleVertexPositionBuffer);
				gl.vertexAttribPointer(circleShaderProgram.vertexPositionAttribute, circleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

				for (var i in circles) {
					if (i == 0) {
						circles[i].draw(true);
					} else {
						circles[i].draw(false);
					}
				}
				
				gl.disableVertexAttribArray(circleShaderProgram.vertexPositionAttribute);
				gl.disableVertexAttribArray(circleShaderProgram.textureCoordAttribute);

			}
			
			function drawGrid() {
				gl.useProgram(gridShaderProgram);
				gl.enableVertexAttribArray(gridShaderProgram.vertexPositionAttribute);
				gl.bindBuffer(gl.ARRAY_BUFFER, gridVertexPositionBuffer);
				gl.vertexAttribPointer(gridShaderProgram.vertexPositionAttribute, gridVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
						
				for (var i = 0; i < 40; i++) {
					for (var j = 0; j < 40; j++) {
						mvPushMatrix();
						mat4.translate(mvMatrix, [(j-20) * SIMULATION_SCALE + (SIMULATION_SCALE / 2.0), (i-20) * SIMULATION_SCALE + (SIMULATION_SCALE / 2.0), 0.0]);
						
						setGridShaderMatrixUniforms();
						gl.drawArrays(gl.LINE_LOOP, 0, gridVertexPositionBuffer.numItems);

						mvPopMatrix();
					}
				}
				
				gl.disableVertexAttribArray(gridShaderProgram.vertexPositionAttribute);
			}
			
			function updateClearColor() {
				if (colorVertex == 0) {
					gl.clearColor(1.0, 0.0, 0.0, clearColorOpacity);
				} else if (colorVertex == 1) {
					gl.clearColor(0.0, 1.0, 0.0, clearColorOpacity);
				} else if (colorVertex == 2) {
					gl.clearColor(0.0, 0.0, 1.0, clearColorOpacity);
				} else if (0 < colorVertex && colorVertex < 1) {
					gl.clearColor(1.0 - colorVertex, colorVertex, 0.0, clearColorOpacity);
				} else if (1 < colorVertex && colorVertex < 2) {
					gl.clearColor(0.0, 2.0 - colorVertex, colorVertex - 1.0, clearColorOpacity);
				} else if (2 < colorVertex && colorVertex < 3) {
					gl.clearColor(colorVertex - 2.0, 0.0, 3.0 - colorVertex, clearColorOpacity);
				}
				gl.clearColor(
					gl.getParameter(gl.COLOR_CLEAR_VALUE)[0] / clearColorDampen,
					gl.getParameter(gl.COLOR_CLEAR_VALUE)[1] / clearColorDampen,
					gl.getParameter(gl.COLOR_CLEAR_VALUE)[2] / clearColorDampen,
					1.0
				);
				colorVertex += clearColorStep;
				if (colorVertex >= 3) colorVertex = 0;
			}

			var lastTime = 0;
			function animate() {
				var timeNow = new Date().getTime();
				if (lastTime != 0) {
					var elapsed = timeNow - lastTime;

					for (var i in circles) {
						circles[i].animate(elapsed);
					}
				}
				lastTime = timeNow;
			}

			function tick() {
				requestAnimFrame(tick);
				handleKeys();
				drawScene();
				animate();
			}

			var defaultDOMSettings = {
				speed: 20,
				numberOfCircles: 12,
				zoom: 25,
				func: "circle",
				tracking: false,
				amplitude: 10
			}
			function initDOM() {
				DOM_sliderSpeed = document.getElementById("DOM_sliderSpeed");
				DOM_sliderSpeed.max = 100;
				DOM_sliderSpeed.min = 1;
				DOM_sliderSpeed.value = defaultDOMSettings.speed;
				
				DOM_sliderAmplitude = document.getElementById("DOM_sliderAmplitude");
				DOM_sliderAmplitude.max = 100;
				DOM_sliderAmplitude.min = 1;
				DOM_sliderAmplitude.value = defaultDOMSettings.amplitude;
				
				DOM_sliderNumberOfCircles = document.getElementById("DOM_sliderNumberOfCircles");
				DOM_sliderNumberOfCircles.max = 200;
				DOM_sliderNumberOfCircles.min = 1;
				DOM_sliderNumberOfCircles.value = defaultDOMSettings.numberOfCircles;
				DOM_sliderNumberOfCircles.oninput = function() {
					initWorldObjects();
				}
				
				DOM_sliderZoom = document.getElementById("DOM_sliderZoom");
				DOM_sliderZoom.max = 200;
				DOM_sliderZoom.min = 1;
				DOM_sliderZoom.value = defaultDOMSettings.zoom;
				
				DOM_selectFunction = document.getElementById("DOM_selectFunction");
				DOM_selectFunction.value = defaultDOMSettings.func;
				DOM_selectFunction.onchange = function() {
					for (var i = 0; i < DOM_selectFunction.options.length; i++) {
						document.getElementById("functionOptions_" + DOM_selectFunction.options[i].value).style.display = "none";
						document.getElementById("functionOptions_" + DOM_selectFunction.value).style.display = "block";
					}
				}
				document.getElementById("functionOptions_circle").style.display = "block";
				
				DOM_trackingCheckbox = document.getElementById("DOM_trackingCheckbox");
				DOM_trackingCheckbox.checked = defaultDOMSettings.tracked;
				
				DOM_trackingPositionSpan = document.getElementById("DOM_trackingPositionSpan");
				DOM_trackingPositionSpan.style.display = "none";
				
				DOM_showGrid = document.getElementById("DOM_showGrid");
				DOM_showGrid.checked = false;
				DOM_showGrid.onchange = function() {
					shouldDrawGrid = DOM_showGrid.checked;
				}
				
				DOM_showFunctionString = document.getElementById("DOM_showFunctionString");
				DOM_showFunctionString.checked = true;
				DOM_showFunctionString.onchange = function() {
					if (DOM_showFunctionString.checked) {
						DOM_functionStringX.style.display = "inline";
						DOM_functionStringY.style.display = "inline";
					} else {
						DOM_functionStringX.style.display = "none";
						DOM_functionStringY.style.display = "none";
					}
				}
				
				DOM_commandLineDiv = document.getElementById("DOM_commandLineDiv");
				DOM_commandLineDiv.style.display = "none";
				DOM_commandLineInput = document.getElementById("DOM_commandLineInput");
				
				DOM_functionOption_rose_k = document.getElementById("DOM_functionOption_rose_k");
				DOM_functionOption_rose_k.max = 8;
				DOM_functionOption_rose_k.min = 1;
				DOM_functionOption_rose_k.value = 2;
			
				DOM_functionOption_lissajous_a = document.getElementById("DOM_functionOption_lissajous_a");
				DOM_functionOption_lissajous_a.max = 6;
				DOM_functionOption_lissajous_a.min = 1;
				DOM_functionOption_lissajous_a.value = 1;
				
				DOM_functionOption_lissajous_b = document.getElementById("DOM_functionOption_lissajous_b");
				DOM_functionOption_lissajous_b.max = 6;
				DOM_functionOption_lissajous_b.min = 1;
				DOM_functionOption_lissajous_b.value = 2;
				
				DOM_functionOption_lissajous_kx = document.getElementById("DOM_functionOption_lissajous_kx");
				DOM_functionOption_lissajous_kx.max = 6;
				DOM_functionOption_lissajous_kx.min = 1;
				DOM_functionOption_lissajous_kx.value = 2;
				
				DOM_functionOption_lissajous_ky = document.getElementById("DOM_functionOption_lissajous_ky");
				DOM_functionOption_lissajous_ky.max = 6;
				DOM_functionOption_lissajous_ky.min = 1;
				DOM_functionOption_lissajous_ky.value = 1;
				
				DOM_functionOption_lissajous_delta = document.getElementById("DOM_functionOption_lissajous_delta");
				DOM_functionOption_lissajous_delta.max = 4;
				DOM_functionOption_lissajous_delta.min = 0;
				DOM_functionOption_lissajous_delta.value = 0;
				
				DOM_functionOption_limacon_a = document.getElementById("DOM_functionOption_limacon_a");
				DOM_functionOption_limacon_a.max = 8;
				DOM_functionOption_limacon_a.min = 0;
				DOM_functionOption_limacon_a.value = 8;
				
				DOM_functionOption_limacon_b = document.getElementById("DOM_functionOption_limacon_b");
				DOM_functionOption_limacon_b.max = 8;
				DOM_functionOption_limacon_b.min = 0;
				DOM_functionOption_limacon_b.value = 8;
				
				DOM_functionStringX = document.getElementById("functionStringX");
				DOM_functionStringY = document.getElementById("functionStringY");
				
			}
			
			function displayCommandLineMessage(text, passed) {
				var span = document.createElement("span");
				if (passed) {
					span.style.color = "green";
				} else {
					span.style.color = "red";
					var errornode = document.createTextNode("ERR: ");
					span.appendChild(errornode);
				}
				var textnode = document.createTextNode(text);
				span.appendChild(textnode);
				span.style.fontFamily = "monospace";
				
				DOM_commandLineDiv.insertBefore(span, DOM_commandLineDiv.children[DOM_commandLineDiv.children.length - 1]);
				DOM_commandLineDiv.insertBefore(document.createElement("br"), DOM_commandLineDiv.children[DOM_commandLineDiv.children.length - 1]);
			}
			
			function displayCommandLineHelp() {
				displayCommandLineMessage("--- Help -------------------------------------", true);
				displayCommandLineMessage("help........: display this window", true);
				displayCommandLineMessage("reset.......: reset the sim", true);
				displayCommandLineMessage("regen.......: regen all circles with given settings", true);
				displayCommandLineMessage("clear.......: clear these messages", true);
				displayCommandLineMessage("speed=?.....: 0 < ? <= 100, sets sim speed", true);
				displayCommandLineMessage("amplitude=?.: 0 < ? <= 10, sets function amplitude", true);
				displayCommandLineMessage("circles=?...: 0 < ? <= 200, sets circle number", true);
				displayCommandLineMessage("zoom=?......: 0 < ? <= 100, sets zoom amount", true);
				displayCommandLineMessage("newcolors...: change all circle colors", true);
				displayCommandLineMessage("drawgrid=?..: true or false to draw grid", true);
				displayCommandLineMessage("----------------------------------------------", true);
			}

			function webGLStart() {
				canvas = document.getElementById("gameCanvas");
				canvas.width = document.body.clientWidth;
				canvas.height = document.body.clientHeight;
				initGL(canvas);
				initDOM();
				initShaders();
				initBuffers();
				initTexture();
				initWorldObjects();

				gl.clearColor(0.0, 0.0, 0.0, 1.0);

				document.onkeydown = handleKeyDown;
				document.onkeyup = handleKeyUp;

				tick();
			}

		</script>


	</head>

	<body oncontextmenu="return false;" onload="webGLStart()" onresize="resizeGL()" style="padding: 0; margin: 0; position: absolute; overflow: hidden;" style="">
		
		<div class="general-options">
			<span>speed&nbsp;&nbsp;&nbsp;&nbsp; </span><input id="DOM_sliderSpeed" type="range"></input><br>
			<span>amplitude </span><input id="DOM_sliderAmplitude" type="range"></input><br>
			<span>circles&nbsp;&nbsp; </span><input id="DOM_sliderNumberOfCircles" type="range"></input><br>
			<span>zoom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><input id="DOM_sliderZoom" type="range"></input><br>
			<span>track&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><input type="checkbox" id="DOM_trackingCheckbox"></input><span id="DOM_trackingPositionSpan"></span><br>
			<span>grid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><input type="checkbox" id="DOM_showGrid"></input><br>
			<span>show fn&nbsp;&nbsp;&nbsp; </span><input type="checkbox" id="DOM_showFunctionString"></input><br>
			<hr>
			<span>function&nbsp;&nbsp; </span><select name="function" id="DOM_selectFunction">
				<option value="butterfly">butterfly</option>
				<option value="cardioid">cardioid</option>
				<option value="circle">circle</option>
				<option value="limacon">lima&ccedil;on</option>
				<option value="lissajous">lissajous</option>
				<option value="rose">rose</option>
			</select><br>
			
			<div id="functionOptions_rose" class="function-options">
				<span>K&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><input id="DOM_functionOption_rose_k" type="range"></input><br>
			</div>
			<div id="functionOptions_cardioid" class="function-options">
				<!-- the limacon handles all modifying of the cardioid, since a cardioid is a specific limacon -->
			</div>
			<div id="functionOptions_circle" class="function-options">
				<!-- the only thing you can change is size and that's amplitude -->
			</div>
			<div id="functionOptions_limacon" class="function-options">
				<span>A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><input id="DOM_functionOption_limacon_a" type="range"></input><br>
				<span>B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><input id="DOM_functionOption_limacon_b" type="range"></input><br>
			</div>
			<div id="functionOptions_lissajous" class="function-options">
				<span>A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><input id="DOM_functionOption_lissajous_a" type="range"></input><br>
				<span>B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><input id="DOM_functionOption_lissajous_b" type="range"></input><br>
				<span>Kx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><input id="DOM_functionOption_lissajous_kx" type="range"></input><br>
				<span>Ky&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><input id="DOM_functionOption_lissajous_ky" type="range"></input><br>
				<span>&delta;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><input id="DOM_functionOption_lissajous_delta" type="range"></input><br>
			</div>
			<div id="functionOptions_butterfly" class="function-options">
				<!-- no options for butterfly, it's way too complicated to begin with -->
			</div>
			
		</div>
		
		<div class="function-string">
			<span id="functionStringX">x function string here...</span><br>
			<span id="functionStringY">y function string here...</span>
		</div>
		
		<div id="DOM_commandLineDiv" class="command-div">
			<input type="text" id="DOM_commandLineInput" style="color: white; font-family: monospace; margin: 0; background-color: transparent; border-top: none; border-right: none;"></input>
		</div>
		
		<div class="ftr ftr-version">
			<span style="font-size: 8">6/15/17 v 1.0</span>
		</div>
		<div class="ftr ftr-top">
			<span>&copy; Zach Reznicek</span>
		</div>
		<div class="ftr ftr-bottom">
			<span style="font-size: 8">like a copyright does anything</span>
		</div>
		
		<canvas id="gameCanvas" style="border: none;"></canvas>
	
	</body>

</html>
