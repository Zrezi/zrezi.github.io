<!DOCTYPE html>
<html>

	<head>
		<meta charset="utf-8">
		<title>WHIP Example &mdash; Rotating Plane</title>

		<style>
			html, body {
				height: 100%;
				width: 100%;
				margin-left: 10px;
				overflow: hidden;
			}
		</style>

		<script type="text/javascript" src="../gl-matrix-min.js"></script>
		<script type="text/javascript" src="../../whip.js"></script>

		<script id="shader-fs" type="fs">
			precision mediump float;

			varying vec2 vTextureCoord;

			uniform sampler2D uSampler;
			uniform bool uIsWireframe;

			void main(void) {
				if (!uIsWireframe) {
					gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));
				} else {
					gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
				}
			}
		</script>

		<script id="shader-vs" type="vs">
			attribute vec3 aVertexPosition;
			attribute vec2 aTextureCoord;

			uniform mat4 uModelViewMatrix;
			uniform mat4 uProjectMatrix;

			varying vec2 vTextureCoord;

			void main(void) {
				gl_Position = uProjectMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
				vTextureCoord = aTextureCoord;
			}
		</script>


		<script type="text/javascript">

			var shaderProgram;
			var marsTexture;

			var modelViewMatrix = mat4.create();
			var projectionMatrix = mat4.create();
			
			var xRot = 0;
			var yRot = 0;
			var zRot = 0;

			var squareVertexPositionBuffer;
			var squareTextureCoordBuffer;
			var squareIndexBuffer;
			
			var lastTime = 0;

			function WHIPPostInit() {
				initShaders();
				initBuffers();
				initTexture();

				WHIP.setClearColor(WHIP.BLACK);
				
				update();
			}
			
			function initShaders() {
				shaderProgram = new WHIP.ShaderProgram("script-element", "shader-fs", "shader-vs");
				shaderProgram.use();

				shaderProgram.addAttribute("aVertexPosition");
				shaderProgram.enableAttribute("aVertexPosition");
				
				shaderProgram.addAttribute("aTextureCoord");
				shaderProgram.enableAttribute("aTextureCoord");

				shaderProgram.addUniform("uProjectMatrix");
				shaderProgram.addUniform("uModelViewMatrix")
				shaderProgram.addUniform("uSampler");
				shaderProgram.addUniform("uIsWireframe");
				
				shaderProgram.setUniform("1i", "uIsWireframe", false);
			}

			function initBuffers() {
				squareVertexPositionBuffer = WHIP.Buffer.squareVerticesBuffer();
				squareTextureCoordBuffer = WHIP.Buffer.squareTextureBuffer();
				squareIndexBuffer = WHIP.Buffer.squareIndicesBuffer();
			}
			
			function initTexture() {
				marsTexture = new WHIP.Texture("mars-lowres.jpg");
				marsTexture.onload = function() {
					this.bind(0);
				};
			}
			
			function update() {
				requestAnimationFrame(update);
				draw();
				animate();
				handleKeys();
			}

			function draw() {
				
				WHIP.clear();
				
				mat4.perspective(projectionMatrix, 45, WHIP.getPerspectiveRatio(), 0.1, 10.0);

				mat4.fromTranslation(modelViewMatrix, [0.0, 0.0, -5.0]);
				mat4.rotate(modelViewMatrix, modelViewMatrix, degToRad(xRot), [1, 0, 0]);
				mat4.rotate(modelViewMatrix, modelViewMatrix, degToRad(yRot), [0, 1, 0]);
				mat4.rotate(modelViewMatrix, modelViewMatrix, degToRad(zRot), [0, 0, 1]);
				
				shaderProgram.setUniform("Matrix4fv", "uModelViewMatrix", modelViewMatrix);
				shaderProgram.setUniform("Matrix4fv", "uProjectMatrix", projectionMatrix);
				
				squareVertexPositionBuffer.bind();
				shaderProgram.attributePointer("aVertexPosition", squareVertexPositionBuffer.itemSize);
				
				squareTextureCoordBuffer.bind();
				shaderProgram.attributePointer("aTextureCoord", squareTextureCoordBuffer.itemSize);
				
				squareIndexBuffer.bind();
				WHIP.drawElements(WHIP.TRIANGLES, squareIndexBuffer.itemCount);
				
			}

			function animate() {
				var timeNow = new Date().getTime();
				if (lastTime != 0) {
					var elapsed = timeNow - lastTime;

					xRot += (90 * elapsed) / 10000.0;
					yRot += (90 * elapsed) / 10000.0;
					zRot += (90 * elapsed) / 10000.0;
				}
				lastTime = timeNow;
			}
			
			function handleKeys() {
				if (WHIP.ifKeyPressed(WHIP.KEY_TAB)) {
					xRot = 0;
					yRot = 0;
					zRot = 0;
				}
				if (WHIP.ifKeyPressed(WHIP.KEY_BACKSPACE)) {
					WHIP.toggleWireframe();
					shaderProgram.setUniform("1i", "uIsWireframe", WHIP.isWireframe());
				}
				if (WHIP.ifKeyHeld(WHIP.KEY_X)) {
					if (WHIP.ifKeyHeld(WHIP.KEY_UP)) {
						xRot += 2;
					}
					if (WHIP.ifKeyHeld(WHIP.KEY_DOWN)) {
						xRot -= 2;
					}
				}
				if (WHIP.ifKeyHeld(WHIP.KEY_Y)) {
					if (WHIP.ifKeyHeld(WHIP.KEY_UP)) {
						yRot += 2;
					}
					if (WHIP.ifKeyHeld(WHIP.KEY_DOWN)) {
						yRot -= 2;
					}
				}
				if (WHIP.ifKeyHeld(WHIP.KEY_Z)) {
					if (WHIP.ifKeyHeld(WHIP.KEY_UP)) {
						zRot += 2;
					}
					if (WHIP.ifKeyHeld(WHIP.KEY_DOWN)) {
						zRot -= 2;
					}
				}
			}
			
			function degToRad(degrees) {
				return degrees * Math.PI / 180;
			}

		</script>

	</head>

	<body oncontextmenu="return false;" onload="WHIP.start()" onresize="WHIP.resize()">
		<canvas id="webgl-canvas" width="500" height="500"></canvas>
		<p>Tab resets the rotations</p>
		<p>Backspace toggles wireframe mode</p>
		<p>Holding UP or DOWN, and then holding X or Y or Z will rotate the plane around that axis</p>
	</body>

</html>
